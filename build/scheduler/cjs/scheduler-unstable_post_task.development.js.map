{"version":3,"file":"scheduler-unstable_post_task.development.js","sources":["../../../../packages/scheduler/src/SchedulerPriorities.js","../../../../packages/scheduler/src/forks/SchedulerPostTask.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;\n\n// TODO: Use symbols?\nexport const NoPriority = 0;\nexport const ImmediatePriority = 1;\nexport const UserBlockingPriority = 2;\nexport const NormalPriority = 3;\nexport const LowPriority = 4;\nexport const IdlePriority = 5;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {PriorityLevel} from '../SchedulerPriorities';\n\ndeclare class TaskController {\n  constructor(priority?: string): TaskController;\n  signal: mixed;\n  abort(): void;\n}\n\ntype PostTaskPriorityLevel = 'user-blocking' | 'user-visible' | 'background';\n\ntype CallbackNode = {|\n  _controller: TaskController,\n|};\n\nimport {\n  ImmediatePriority,\n  UserBlockingPriority,\n  NormalPriority,\n  LowPriority,\n  IdlePriority,\n} from '../SchedulerPriorities';\n\nexport {\n  ImmediatePriority as unstable_ImmediatePriority,\n  UserBlockingPriority as unstable_UserBlockingPriority,\n  NormalPriority as unstable_NormalPriority,\n  IdlePriority as unstable_IdlePriority,\n  LowPriority as unstable_LowPriority,\n};\n\n// Capture local references to native APIs, in case a polyfill overrides them.\nconst perf = window.performance;\nconst setTimeout = window.setTimeout;\n\n// Use experimental Chrome Scheduler postTask API.\nconst scheduler = global.scheduler;\n\nconst getCurrentTime = perf.now.bind(perf);\n\nexport const unstable_now = getCurrentTime;\n\n// Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\nconst yieldInterval = 5;\nlet deadline = 0;\n\nlet currentPriorityLevel_DEPRECATED = NormalPriority;\n\n// `isInputPending` is not available. Since we have no way of knowing if\n// there's pending input, always yield at the end of the frame.\nexport function unstable_shouldYield() {\n  return getCurrentTime() >= deadline;\n}\n\nexport function unstable_requestPaint() {\n  // Since we yield every frame regardless, `requestPaint` has no effect.\n}\n\ntype SchedulerCallback<T> = (\n  didTimeout_DEPRECATED: boolean,\n) =>\n  | T\n  // May return a continuation\n  | SchedulerCallback<T>;\n\nexport function unstable_scheduleCallback<T>(\n  priorityLevel: PriorityLevel,\n  callback: SchedulerCallback<T>,\n  options?: {delay?: number},\n): CallbackNode {\n  let postTaskPriority;\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n      postTaskPriority = 'user-blocking';\n      break;\n    case LowPriority:\n    case NormalPriority:\n      postTaskPriority = 'user-visible';\n      break;\n    case IdlePriority:\n      postTaskPriority = 'background';\n      break;\n    default:\n      postTaskPriority = 'user-visible';\n      break;\n  }\n\n  const controller = new TaskController();\n  const postTaskOptions = {\n    priority: postTaskPriority,\n    delay: typeof options === 'object' && options !== null ? options.delay : 0,\n    signal: controller.signal,\n  };\n\n  const node = {\n    _controller: controller,\n  };\n\n  scheduler\n    .postTask(\n      runTask.bind(null, priorityLevel, postTaskPriority, node, callback),\n      postTaskOptions,\n    )\n    .catch(handleAbortError);\n\n  return node;\n}\n\nfunction runTask<T>(\n  priorityLevel: PriorityLevel,\n  postTaskPriority: PostTaskPriorityLevel,\n  node: CallbackNode,\n  callback: SchedulerCallback<T>,\n) {\n  deadline = getCurrentTime() + yieldInterval;\n  try {\n    currentPriorityLevel_DEPRECATED = priorityLevel;\n    const didTimeout_DEPRECATED = false;\n    const result = callback(didTimeout_DEPRECATED);\n    if (typeof result === 'function') {\n      // Assume this is a continuation\n      const continuation: SchedulerCallback<T> = (result: any);\n      const continuationController = new TaskController();\n      const continuationOptions = {\n        priority: postTaskPriority,\n        signal: continuationController.signal,\n      };\n      // Update the original callback node's controller, since even though we're\n      // posting a new task, conceptually it's the same one.\n      node._controller = continuationController;\n      scheduler\n        .postTask(\n          runTask.bind(\n            null,\n            priorityLevel,\n            postTaskPriority,\n            node,\n            continuation,\n          ),\n          continuationOptions,\n        )\n        .catch(handleAbortError);\n    }\n  } catch (error) {\n    // We're inside a `postTask` promise. If we don't handle this error, then it\n    // will trigger an \"Unhandled promise rejection\" error. We don't want that,\n    // but we do want the default error reporting behavior that normal\n    // (non-Promise) tasks get for unhandled errors.\n    //\n    // So we'll re-throw the error inside a regular browser task.\n    setTimeout(() => {\n      throw error;\n    });\n  } finally {\n    currentPriorityLevel_DEPRECATED = NormalPriority;\n  }\n}\n\nfunction handleAbortError(error) {\n  // Abort errors are an implementation detail. We don't expose the\n  // TaskController to the user, nor do we expose the promise that is returned\n  // from `postTask`. So we should suppress them, since there's no way for the\n  // user to handle them.\n}\n\nexport function unstable_cancelCallback(node: CallbackNode) {\n  const controller = node._controller;\n  controller.abort();\n}\n\nexport function unstable_runWithPriority<T>(\n  priorityLevel: PriorityLevel,\n  callback: () => T,\n): T {\n  const previousPriorityLevel = currentPriorityLevel_DEPRECATED;\n  currentPriorityLevel_DEPRECATED = priorityLevel;\n  try {\n    return callback();\n  } finally {\n    currentPriorityLevel_DEPRECATED = previousPriorityLevel;\n  }\n}\n\nexport function unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel_DEPRECATED;\n}\n\nexport function unstable_next<T>(callback: () => T): T {\n  let priorityLevel;\n  switch (currentPriorityLevel_DEPRECATED) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel_DEPRECATED;\n      break;\n  }\n\n  const previousPriorityLevel = currentPriorityLevel_DEPRECATED;\n  currentPriorityLevel_DEPRECATED = priorityLevel;\n  try {\n    return callback();\n  } finally {\n    currentPriorityLevel_DEPRECATED = previousPriorityLevel;\n  }\n}\n\nexport function unstable_wrapCallback<T>(callback: () => T): () => T {\n  const parentPriorityLevel = currentPriorityLevel_DEPRECATED;\n  return () => {\n    const previousPriorityLevel = currentPriorityLevel_DEPRECATED;\n    currentPriorityLevel_DEPRECATED = parentPriorityLevel;\n    try {\n      return callback();\n    } finally {\n      currentPriorityLevel_DEPRECATED = previousPriorityLevel;\n    }\n  };\n}\n\nexport function unstable_forceFrameRate() {}\n\nexport function unstable_pauseExecution() {}\n\nexport function unstable_continueExecution() {}\n\nexport function unstable_getFirstCallbackNode() {\n  return null;\n}\n\n// Currently no profiling build\nexport const unstable_Profiling = null;\n"],"names":["ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","perf","window","performance","setTimeout","scheduler","global","getCurrentTime","now","bind","unstable_now","yieldInterval","deadline","currentPriorityLevel_DEPRECATED","unstable_shouldYield","unstable_requestPaint","unstable_scheduleCallback","priorityLevel","callback","options","postTaskPriority","controller","TaskController","postTaskOptions","priority","delay","signal","node","_controller","postTask","runTask","catch","handleAbortError","didTimeout_DEPRECATED","result","continuation","continuationController","continuationOptions","error","unstable_cancelCallback","abort","unstable_runWithPriority","previousPriorityLevel","unstable_getCurrentPriorityLevel","unstable_next","unstable_wrapCallback","parentPriorityLevel","unstable_forceFrameRate","unstable_pauseExecution","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_Profiling"],"mappings":"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"}